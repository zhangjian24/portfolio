---
title: "(LLMç³»åˆ—)æµå¼è¾“å‡º(Streaming)å®ç°ï¼šæå‡ç”¨æˆ·ä½“éªŒ"
description: "(LLMç³»åˆ—)æµå¼è¾“å‡º(Streaming)å®ç°ï¼šæå‡ç”¨æˆ·ä½“éªŒ"
pubDate: 2026-02-02
heroImage: '/image/logo.svg'
tags: ["SSE","Streaming","Next.js", "Qwen", "AI"]
---

# æµå¼è¾“å‡º(Streaming)å®ç°ï¼šæå‡ç”¨æˆ·ä½“éªŒ

åœ¨ç°ä»£ Web åº”ç”¨ä¸­ï¼Œç”¨æˆ·ä½“éªŒçš„å…³é”®åœ¨äºå“åº”é€Ÿåº¦å’Œäº¤äº’åé¦ˆã€‚å½“å¤„ç†è€—æ—¶æ“ä½œæ—¶ï¼Œä¼ ç»Ÿçš„"ç­‰å¾…-è¿”å›"æ¨¡å¼å¾€å¾€è®©ç”¨æˆ·æ„Ÿåˆ°ç„¦è™‘ã€‚æµå¼è¾“å‡ºï¼ˆStreamingï¼‰æŠ€æœ¯é€šè¿‡é€æ­¥è¿”å›æ•°æ®ï¼Œè®©ç”¨æˆ·å®æ—¶çœ‹åˆ°å¤„ç†è¿›åº¦ï¼Œæå¤§æå‡äº†ä½“éªŒæ„ŸçŸ¥ã€‚æœ¬æ–‡å°†æ·±å…¥æ¢è®¨å¦‚ä½•åœ¨ Qwen Chatbot é¡¹ç›®ä¸­ä½¿ç”¨ SSEï¼ˆServer-Sent Eventsï¼‰å’Œå¼‚æ­¥å¤„ç†å®ç°æµå¼è¾“å‡ºã€‚

## ä¸ºä»€ä¹ˆéœ€è¦æµå¼è¾“å‡ºï¼Ÿ

æƒ³è±¡ä¸€ä¸ªåœºæ™¯ï¼šç”¨æˆ·å‘ AI åŠ©æ‰‹æé—®ï¼Œä¼ ç»Ÿæ–¹å¼éœ€è¦ç­‰å¾…å®Œæ•´ç­”æ¡ˆç”Ÿæˆåæ‰èƒ½çœ‹åˆ°ç»“æœï¼Œå¯èƒ½éœ€è¦ç­‰å¾…æ•°åç§’ã€‚è€Œæµå¼è¾“å‡ºå…è®¸ç­”æ¡ˆé€å­—é€å¥åœ°å‘ˆç°ï¼Œå°±åƒçœŸäººå¯¹è¯ä¸€æ ·è‡ªç„¶ã€‚è¿™ç§å³æ—¶åé¦ˆä¸ä»…å‡å°‘äº†æ„ŸçŸ¥ç­‰å¾…æ—¶é—´ï¼Œè¿˜å¢å¼ºäº†åº”ç”¨çš„äº’åŠ¨æ€§ã€‚

æµå¼è¾“å‡ºçš„å…¸å‹åº”ç”¨åœºæ™¯åŒ…æ‹¬ï¼š
- AI å¯¹è¯ç³»ç»Ÿï¼ˆChatGPT å¼äº¤äº’ï¼‰
- å¤§æ–‡ä»¶å¤„ç†è¿›åº¦
- å®æ—¶æ—¥å¿—è¾“å‡º
- æ•°æ®åˆ†ææŠ¥å‘Šç”Ÿæˆ

## æŠ€æœ¯é€‰å‹ï¼šä¸ºä»€ä¹ˆé€‰æ‹© SSEï¼Ÿ

åœ¨å®ç°æµå¼æ•°æ®ä¼ è¾“æ—¶ï¼Œæˆ‘ä»¬æœ‰å‡ ç§é€‰æ‹©ï¼šWebSocketã€HTTP/2 Server Push å’Œ SSEã€‚å¯¹äºå•å‘æ•°æ®æµï¼ˆæœåŠ¡å™¨åˆ°å®¢æˆ·ç«¯ï¼‰ï¼ŒSSE æ˜¯æœ€ä¼˜æ–¹æ¡ˆï¼š

- **ç®€å•æ˜“ç”¨**ï¼šåŸºäº HTTP åè®®ï¼Œæ— éœ€å¤æ‚æ¡æ‰‹
- **è‡ªåŠ¨é‡è¿**ï¼šæµè§ˆå™¨åŸç”Ÿæ”¯æŒæ–­çº¿é‡è¿
- **è½»é‡çº§**ï¼šç›¸æ¯” WebSocket æ›´èŠ‚çœèµ„æº
- **é˜²ç«å¢™å‹å¥½**ï¼šä½¿ç”¨æ ‡å‡† HTTP ç«¯å£

## Qwen Chatbot é¡¹ç›®ä¸­çš„å®ç°æ–¹æ¡ˆ

### æœåŠ¡ç«¯ï¼šAPI è·¯ç”±å®ç°

Next.js çš„ Pages Router æä¾›äº†å¼ºå¤§çš„ API è·¯ç”±åŠŸèƒ½ï¼Œéå¸¸é€‚åˆå®ç° SSEã€‚ä»¥ä¸‹æ˜¯ Qwen Chatbot é¡¹ç›®ä¸­çš„å®Œæ•´å®ç°ç¤ºä¾‹ï¼š

```typescript
// pages/api/qwen.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import OpenAI from 'openai';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { messages, stream = false, model, temperature = 0.7, top_p = 0.9, max_tokens = 2048 } = req.body;

  // éªŒè¯å¿…éœ€å­—æ®µ
  if (!messages || !Array.isArray(messages)) {
    return res.status(400).json({ error: 'Messages are required and must be an array' });
  }

  try {
    // åˆ›å»º OpenAI å…¼å®¹çš„å®¢æˆ·ç«¯ï¼Œé€‚é…é€šä¹‰åƒé—®
    const client = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY || '',
      baseURL: process.env.OPENAI_API_BASE || 'https://dashscope.aliyuncs.com/compatible-mode/v1',
    });

    if (stream) {
      // ä½¿ç”¨ TransformStream å®ç°æµå¼å“åº”
      const encoder = new TextEncoder();
      const stream = new TransformStream();
      const writer = stream.writable.getWriter();

      // å¼‚æ­¥å¤„ç†å‡½æ•°
      (async () => {
        try {
          // é€šä¹‰åƒé—®APIæ”¯æŒsystem messageï¼Œç›´æ¥ä½¿ç”¨åŸå§‹æ¶ˆæ¯
          const response = await client.chat.completions.create({
            model: model || process.env.MODEL_NAME || 'qwen-max',
            messages,
            stream: true,
            temperature,
            top_p,
            max_tokens,
            stream_options: { include_usage: true }, // åŒ…å«ä½¿ç”¨é‡ä¿¡æ¯
          });

          // é€å—å‘é€æ•°æ®
          for await (const chunk of response) {
            const content = chunk.choices[0]?.delta?.content;
            
            // å¦‚æœæœ‰å†…å®¹ï¼Œå‘é€å†…å®¹æ•°æ®
            if (content) {
              const data = `data: ${JSON.stringify({ content })}\n\n`;
              await writer.write(encoder.encode(data));
            }
            
            // å¦‚æœæœ‰usageä¿¡æ¯ï¼Œå‘é€tokenä½¿ç”¨æ•°æ®
            if (chunk.usage) {
              const tokenData = {
                usage: {
                  prompt_tokens: chunk.usage.prompt_tokens,
                  completion_tokens: chunk.usage.completion_tokens,
                  total_tokens: chunk.usage.total_tokens,
                }
              };
              const data = `data: ${JSON.stringify(tokenData)}\n\n`;
              await writer.write(encoder.encode(data));
            }
          }
          
          // å‘é€ç»“æŸä¿¡å·
          await writer.write(encoder.encode('data: [DONE]\n\n'));
        } catch (error: any) {
          // å‘é€é”™è¯¯ä¿¡æ¯
          await writer.write(
            encoder.encode(`data: ${JSON.stringify({ error: error.message || 'AI service error' })}\n\n`)
          );
        } finally {
          await writer.close();
        }
      })();

      // è¿”å› SSE å“åº”
      res.setHeader('Content-Type', 'text/event-stream');
      res.setHeader('Cache-Control', 'no-cache');
      res.setHeader('Connection', 'keep-alive');
      return new Response(stream.readable, {
        headers: {
          'Content-Type': 'text/event-stream',
          'Cache-Control': 'no-cache',
          'Connection': 'keep-alive',
        },
      });
    } else {
      // éæµå¼å“åº”
      // é€šä¹‰åƒé—®APIæ”¯æŒsystem messageï¼Œç›´æ¥ä½¿ç”¨åŸå§‹æ¶ˆæ¯
      const response = await client.chat.completions.create({
        model: model || process.env.MODEL_NAME || 'qwen-max',
        messages,
        temperature,
        top_p,
        max_tokens,
      });

      const content = response.choices[0]?.message?.content || '';
      const usage = response.usage;
      
      res.status(200).json({ 
        content, 
        usage: usage ? {
          prompt_tokens: usage.prompt_tokens,
          completion_tokens: usage.completion_tokens,
          total_tokens: usage.total_tokens,
        } : undefined
      });
    }
  } catch (error: any) {
    console.error('Error calling Qwen API:', error);
    
    let errorMessage = 'An error occurred while calling the API';
    let statusCode = 500;
    
    if (error.status === 401) {
      errorMessage = 'Authentication failed. Please check your API key.';
      statusCode = 401;
    } else if (error.status === 403) {
      errorMessage = 'Access forbidden. Please check your API permissions.';
      statusCode = 403;
    } else if (error.status === 429) {
      errorMessage = 'Rate limit exceeded. Please try again later.';
      statusCode = 429;
    } else if (error.status === 404 && error.message.includes('model')) {
      errorMessage = 'Model not found or access denied. Please check the model name and your API permissions. Try using "qwen-max" instead of "qwen-max-0102".';
      statusCode = 404;
    } else if (error.message) {
      errorMessage = error.message;
    }
    
    res.status(statusCode).json({ 
      error: errorMessage,
      details: process.env.NODE_ENV === 'development' ? error.toString() : undefined
    });
  }
}
```

å…³é”®ç‚¹è§£æï¼š

1. **TransformStream**ï¼šNext.js æ¨èçš„æµå¤„ç†æ–¹å¼ï¼Œæ¯”ä¼ ç»Ÿçš„ ReadableStream æ›´çµæ´»
2. **TextEncoder**ï¼šå°†å­—ç¬¦ä¸²è½¬æ¢ä¸º Uint8Arrayï¼Œç¬¦åˆæµä¼ è¾“è¦æ±‚
3. **SSE æ ¼å¼**ï¼šæ•°æ®å¿…é¡»ä»¥ `data: ` å¼€å¤´ï¼Œä»¥ `\n\n` ç»“å°¾
4. **å¼‚æ­¥ IIFE**ï¼šç«‹å³æ‰§è¡Œçš„å¼‚æ­¥å‡½æ•°ï¼Œé¿å…é˜»å¡å“åº”è¿”å›
5. **é€šä¹‰åƒé—®é€‚é…**ï¼šä½¿ç”¨ OpenAI å…¼å®¹çš„ API å®¢æˆ·ç«¯ï¼Œé€‚é…é€šä¹‰åƒé—® API

### å®¢æˆ·ç«¯ï¼šReact ç»„ä»¶å®ç°

å®¢æˆ·ç«¯éœ€è¦å¤„ç† SSE è¿æ¥å¹¶å®æ—¶æ›´æ–° UIï¼Œä»¥ä¸‹æ˜¯ Qwen Chatbot é¡¹ç›®ä¸­çš„å®ç°ï¼š

```typescript
// pages/chat.tsx (SSE å¤„ç†éƒ¨åˆ†)
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();
  if (!inputMessage.trim() || isLoading) return;

  // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
  const userMessage = { role: 'user', content: inputMessage };
  dispatch({ type: 'ADD_MESSAGE', payload: userMessage });
  dispatch({ type: 'SET_INPUT_MESSAGE', payload: '' });
  setIsLoading(true);

  try {
    // å‡†å¤‡æ¶ˆæ¯æ•°ç»„ï¼Œå¦‚æœé€‰æ‹©äº†è§’è‰²å¹¶ä¸”è¯¥è§’è‰²æœ‰ç³»ç»Ÿæç¤ºï¼Œåˆ™åœ¨å¼€å¤´æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
    let messagesToSend = [...messages, userMessage];
    
    if (selectedRoleId) {
      const selectedRole = roles.find(r => r.id === selectedRoleId);
      if (selectedRole && selectedRole.systemPrompt) {
        // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰ç³»ç»Ÿæ¶ˆæ¯ï¼Œå¦‚æœæ²¡æœ‰åˆ™æ·»åŠ 
        const hasSystemMessage = messages.some(msg => msg.role === 'system');
        if (!hasSystemMessage) {
          messagesToSend = [{ role: 'system', content: selectedRole.systemPrompt }, ...messagesToSend];
        }
      }
    }
    
    // å‘é€è¯·æ±‚åˆ°åç«¯ API
    // ä½¿ç”¨æµå¼å“åº”è·å–å®æ—¶tokenä½¿ç”¨æƒ…å†µ
    const response = await fetch('/api/qwen', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        messages: messagesToSend,
        stream: true, // ä½¿ç”¨æµå¼å“åº”
        model: modelConfig.model,
        temperature: modelConfig.temperature,
        top_p: modelConfig.top_p,
        max_tokens: modelConfig.max_tokens,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || 'Failed to get response from API');
    }

    // å¤„ç†æµå¼å“åº”
    const reader = response.body?.getReader();
    if (!reader) {
      throw new Error('Could not read response body');
    }

    const decoder = new TextDecoder();
    let assistantMessage: Message = { role: 'assistant', content: '', usage: undefined };
    
    // åˆ›å»ºåŠ©æ‰‹æ¶ˆæ¯å¹¶æ·»åŠ åˆ°æ¶ˆæ¯åˆ—è¡¨
    const newAssistantMessage: Message = { role: 'assistant', content: '', usage: undefined };
    dispatch({ type: 'ADD_MESSAGE', payload: newAssistantMessage });

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const chunk = decoder.decode(value, { stream: true });
      const lines = chunk.split('\n');

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6); // ç§»é™¤ 'data: ' å‰ç¼€
          
          if (data === '[DONE]') {
            // æµç»“æŸ
            break;
          }

          try {
            const parsed = JSON.parse(data);
            if (parsed.content) {
              // æ›´æ–°æœ€åä¸€æ¡æ¶ˆæ¯çš„å†…å®¹
              assistantMessage.content += parsed.content;
              // åªæ›´æ–°åŠ©æ‰‹æ¶ˆæ¯ï¼Œä¿ç•™ä¹‹å‰çš„æ¶ˆæ¯
              const updatedMessages = [...messages, { ...assistantMessage }];
              dispatch({ type: 'SET_MESSAGES', payload: updatedMessages });
            } else if (parsed.usage) {
              // æ›´æ–°æœ€åä¸€æ¡æ¶ˆæ¯çš„ä½¿ç”¨æƒ…å†µ
              assistantMessage.usage = parsed.usage;
              const updatedMessages = [...messages, { ...assistantMessage }];
              dispatch({ type: 'SET_MESSAGES', payload: updatedMessages });
            }
          } catch (e) {
            // å¿½ç•¥æ— æ³•è§£æçš„æ•°æ®è¡Œ
            console.error('Error parsing data:', e);
          }
        }
      }
    }
    
    // åœ¨æµç»“æŸåè®°å½•å¯¹è¯å†å²
    const updatedMessages = [...messages, assistantMessage]; // è·å–åŒ…å«æœ€æ–°æ¶ˆæ¯çš„å®Œæ•´æ¶ˆæ¯åˆ—è¡¨
    const lastAssistantMessage = updatedMessages[updatedMessages.length - 1]; // æœ€åä¸€æ¡æ¶ˆæ¯åº”è¯¥æ˜¯åŠ©æ‰‹çš„å›å¤
    
    if (lastAssistantMessage && lastAssistantMessage.role === 'assistant') {
      const newHistoryEntry: ConversationHistory = {
        id: Date.now(), // ä½¿ç”¨æ—¶é—´æˆ³ä½œä¸ºå”¯ä¸€ID
        timestamp: new Date().toISOString(),
        input: inputMessage,
        output: lastAssistantMessage.content,
        model: modelConfig.model,
        params: {
          temperature: modelConfig.temperature,
          top_p: modelConfig.top_p,
          max_tokens: modelConfig.max_tokens,
        },
        tokenUsage: assistantMessage.usage ? {
          prompt_tokens: assistantMessage.usage.prompt_tokens,
          completion_tokens: assistantMessage.usage.completion_tokens,
          total_tokens: assistantMessage.usage.total_tokens
        } : undefined,
        evaluation: '' // å¯ä»¥è®©ä½¿ç”¨è€…æ‰‹åŠ¨å¡«å†™æˆ–ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆ
      };
      
      dispatch({ type: 'ADD_TO_HISTORY', payload: newHistoryEntry }); // æ·»åŠ åˆ°å†å²è®°å½•å¼€å¤´
    }
  } catch (error: any) {
    console.error('Error:', error);
    dispatch({ type: 'ADD_MESSAGE', payload: {
      role: 'assistant',
      content: `Error: ${error.message || 'An unknown error occurred'}`
    }});
    
    // å³ä½¿å‡ºé”™ä¹Ÿè®°å½•å†å²
    const errorMessage = `Error: ${error.message || 'An unknown error occurred'}`;
    const newHistoryEntry: ConversationHistory = {
      id: Date.now(), // ä½¿ç”¨æ—¶é—´æˆ³ä½œä¸ºå”¯ä¸€ID
      timestamp: new Date().toISOString(),
      input: inputMessage,
      output: errorMessage,
      model: modelConfig.model,
      params: {
        temperature: modelConfig.temperature,
        top_p: modelConfig.top_p,
        max_tokens: modelConfig.max_tokens,
      },
      tokenUsage: undefined, // é”™è¯¯æƒ…å†µä¸‹æ— tokenä½¿ç”¨æ•°æ®
      evaluation: 'Error occurred' // æ ‡è®°ä¸ºé”™è¯¯
    };
    
    dispatch({ type: 'ADD_TO_HISTORY', payload: newHistoryEntry }); // æ·»åŠ åˆ°å†å²è®°å½•å¼€å¤´
  } finally {
    setIsLoading(false);
  }
};
```

æ ¸å¿ƒå®ç°è¦ç‚¹ï¼š

1. **ReadableStream Reader**ï¼šä½¿ç”¨ `getReader()` é€å—è¯»å–æ•°æ®
2. **TextDecoder**ï¼šå°†äºŒè¿›åˆ¶æ•°æ®è§£ç ä¸ºå­—ç¬¦ä¸²
3. **çŠ¶æ€æ›´æ–°**ï¼šé€šè¿‡ Redux-like çŠ¶æ€ç®¡ç†æ›´æ–°æ¶ˆæ¯
4. **é”™è¯¯å¤„ç†**ï¼šå¦¥å–„å¤„ç†è§£æé”™è¯¯å’Œç½‘ç»œå¼‚å¸¸
5. **Token ä½¿ç”¨æƒ…å†µ**ï¼šå®æ—¶æ›´æ–° API è°ƒç”¨çš„ token ä½¿ç”¨æƒ…å†µ

### å‰ç«¯æ‰“å­—æœºæ•ˆæœå®ç°

ä¸ºäº†è®©æµå¼è¾“å‡ºçœ‹èµ·æ¥æ›´è‡ªç„¶ï¼Œæˆ‘ä»¬åœ¨å‰ç«¯å®ç°äº†æ‰“å­—æœºæ•ˆæœï¼š

```typescript
// components/TypeWriterEffect.tsx
import React, { useState, useEffect, useRef } from 'react';
import styles from '../styles/TypeWriterEffect.module.css';

interface TypeWriterEffectProps {
  text: string;
  speed?: number; // æ‰“å­—é€Ÿåº¦ï¼Œæ¯«ç§’/å­—ç¬¦
  className?: string; // è‡ªå®šä¹‰ç±»å
}

const TypeWriterEffect: React.FC<TypeWriterEffectProps> = ({ 
  text, 
  speed = 50, // æ”¾æ…¢é€Ÿåº¦åˆ°50ms/å­—ç¬¦ï¼Œè®©æ•ˆæœæ›´æ˜æ˜¾
  className = ''
}) => {
  const [displayedText, setDisplayedText] = useState('');
  const [isTyping, setIsTyping] = useState(true);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    // æ¯æ¬¡textå˜åŒ–æ—¶é‡ç½®
    setDisplayedText('');
    setIsTyping(true);
    
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    // å¦‚æœæ–‡æœ¬ä¸ºç©ºï¼Œç›´æ¥è¿”å›
    if (!text) {
      setIsTyping(false);
      return;
    }

    // å¼€å§‹æ‰“å­—
    let index = 0;
    const typeNextChar = () => {
      if (index < text.length) {
        const char = text[index];
        // ç¡®ä¿å­—ç¬¦ä¸æ˜¯undefinedæˆ–null
        if (char !== undefined && char !== null) {
          // å¼ºåˆ¶æ›´æ–°ï¼Œé¿å…Reactä¼˜åŒ–
          setDisplayedText(prev => prev + String(char));
        }
        index++;
        timeoutRef.current = setTimeout(typeNextChar, speed);
      } else {
        setIsTyping(false);
      }
    };

    timeoutRef.current = setTimeout(typeNextChar, speed);

    // æ¸…ç†
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, [text, speed]);

  return (
    <span className={`${styles.typeWriterText} ${className}`}>
      {displayedText}
      {isTyping && <span className={styles.cursor}>|</span>}
    </span>
  );
};

export default TypeWriterEffect;
```

## æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 1. èƒŒå‹å¤„ç†ï¼ˆBackpressureï¼‰

å½“å®¢æˆ·ç«¯å¤„ç†é€Ÿåº¦è·Ÿä¸ä¸ŠæœåŠ¡ç«¯å‘é€é€Ÿåº¦æ—¶ï¼Œéœ€è¦å®ç°èƒŒå‹æœºåˆ¶ï¼š

```typescript
const writer = stream.writable.getWriter();

async function writeWithBackpressure(data: string) {
  await writer.ready; // ç­‰å¾…ç¼“å†²åŒºå¯å†™
  await writer.write(encoder.encode(data));
}
```

### 2. åˆ†å—ç­–ç•¥

åˆç†æ§åˆ¶æ¯æ¬¡å‘é€çš„æ•°æ®é‡ï¼Œé¿å…è¿‡å°ï¼ˆé¢‘ç¹ç½‘ç»œå¼€é”€ï¼‰æˆ–è¿‡å¤§ï¼ˆå¤±å»æµå¼æ•ˆæœï¼‰ï¼š

```typescript
let buffer = '';
const CHUNK_SIZE = 50; // æ¯ 50 ä¸ªå­—ç¬¦å‘é€ä¸€æ¬¡

for (const char of response) {
  buffer += char;
  if (buffer.length >= CHUNK_SIZE) {
    await writeWithBackpressure(`data: ${JSON.stringify({ content: buffer })}\n\n`);
    buffer = '';
  }
}
```

### 3. è¿æ¥ç®¡ç†

å®ç°å¿ƒè·³æ£€æµ‹ï¼Œé˜²æ­¢è¿æ¥æ„å¤–æ–­å¼€ï¼š

```typescript
// æœåŠ¡ç«¯å®šæœŸå‘é€å¿ƒè·³
const heartbeatInterval = setInterval(() => {
  writer.write(encoder.encode(': heartbeat\n\n'));
}, 30000);

// æ¸…ç†
process.on('exit', () => clearInterval(heartbeatInterval));
```

## å®æˆ˜æ¡ˆä¾‹ï¼šQwen Chatbot ä¸­çš„é›†æˆ

åœ¨ Qwen Chatbot é¡¹ç›®ä¸­ï¼Œæˆ‘ä»¬å°†ä»¥ä¸ŠæŠ€æœ¯æ•´åˆåˆ°äº†çœŸå®çš„ AI å¯¹è¯ç³»ç»Ÿä¸­ï¼š

1. **æ¶ˆæ¯ç»„ä»¶é›†æˆ**ï¼šåœ¨ ChatWindow ç»„ä»¶ä¸­ä½¿ç”¨ TypeWriterEffect æ˜¾ç¤ºåŠ©æ‰‹å›å¤
2. **çŠ¶æ€ç®¡ç†**ï¼šä½¿ç”¨å…¨å±€çŠ¶æ€ç®¡ç†å™¨è·Ÿè¸ªæ¶ˆæ¯æµ
3. **å®æ—¶æ›´æ–°**ï¼šSSE æµå®æ—¶æ›´æ–°åŠ©æ‰‹æ¶ˆæ¯å†…å®¹
4. **æ‰“å­—æ•ˆæœ**ï¼šå‰ç«¯å®ç°çš„æ‰“å­—æœºæ•ˆæœå¢å¼ºç”¨æˆ·ä½“éªŒ

```typescript
// components/ChatWindow.tsx
import TypeWriterEffect from './TypeWriterEffect';

// ...

{messages.map((msg, index) => (
  <div key={index} className={`${styles.message} ${styles[msg.role]}`}>
    <div className={styles.avatar}>
      {msg.role === 'user' ? 'ğŸ‘¤' : 'ğŸ¤–'}
    </div>
    <div className={styles.content}>
      {msg.role === 'assistant' ? (
        <TypeWriterEffect text={msg.content} speed={20} />
      ) : (
        msg.content
      )}
      {msg.usage && (
        <div className={styles.tokenInfo}>
          Tokens: {msg.usage.total_tokens} (Prompt: {msg.usage.prompt_tokens}, Completion: {msg.usage.completion_tokens})
        </div>
      )}
    </div>
  </div>
))}
```

## æ³¨æ„äº‹é¡¹ä¸æœ€ä½³å®è·µ

1. **è¶…æ—¶å¤„ç†**ï¼šè®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´ï¼Œé¿å…è¿æ¥æ°¸ä¹…æŒ‚èµ·
2. **é”™è¯¯æ¢å¤**ï¼šå®¢æˆ·ç«¯åº”å®ç°é‡è¯•æœºåˆ¶ï¼Œå¤„ç†ç½‘ç»œæ³¢åŠ¨
3. **èµ„æºæ¸…ç†**ï¼šç¡®ä¿ writer å’Œ reader æ­£ç¡®å…³é—­ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
4. **CORS é…ç½®**ï¼šè·¨åŸŸåœºæ™¯éœ€è¦æ­£ç¡®é…ç½®å“åº”å¤´
5. **è¿›åº¦æŒ‡ç¤º**ï¼šæä¾›æ˜ç¡®çš„åŠ è½½çŠ¶æ€ï¼Œè®©ç”¨æˆ·çŸ¥é“ç³»ç»Ÿæ­£åœ¨å·¥ä½œ
6. **æ‰“å­—æœºæ•ˆæœä¼˜åŒ–**ï¼šä¸èƒ½ä¾èµ– SSE è¿”å›ç²’åº¦ï¼Œå¿…é¡»åœ¨å‰ç«¯ä¸»åŠ¨æ§åˆ¶æ˜¾ç¤ºèŠ‚å¥
7. **API å…¼å®¹æ€§**ï¼šé€‚é…ä¸åŒ LLM æä¾›å•†çš„ API æ ¼å¼å·®å¼‚

## æ€»ç»“

æµå¼è¾“å‡ºé€šè¿‡ SSE å’Œå¼‚æ­¥å¤„ç†æŠ€æœ¯ï¼Œå°†"ç­‰å¾…-è¿”å›"çš„äº¤äº’æ¨¡å¼è½¬å˜ä¸º"å®æ—¶åé¦ˆ"çš„ä½“éªŒã€‚åœ¨ Qwen Chatbot é¡¹ç›®ä¸­ï¼Œå€ŸåŠ© Next.js å’Œ Web Streams APIï¼Œæˆ‘ä»¬ä¼˜é›…åœ°å®ç°äº†è¿™ä¸€åŠŸèƒ½ã€‚æ— è®ºæ˜¯ AI å¯¹è¯ã€æ•°æ®å¤„ç†è¿˜æ˜¯å®æ—¶æ—¥å¿—ï¼Œæµå¼è¾“å‡ºéƒ½èƒ½æ˜¾è‘—æå‡ç”¨æˆ·ä½“éªŒã€‚

é€šè¿‡ç»“åˆåç«¯æµå¼ä¼ è¾“å’Œå‰ç«¯æ‰“å­—æœºæ•ˆæœï¼Œæˆ‘ä»¬å®ç°äº†æ—¢é«˜æ•ˆåˆç›´è§‚çš„ç”¨æˆ·äº¤äº’ä½“éªŒã€‚éšç€ Web æŠ€æœ¯çš„å‘å±•ï¼Œæµå¼å¤„ç†å°†æˆä¸ºæ„å»ºç°ä»£ AI åº”ç”¨çš„æ ‡é…èƒ½åŠ›ã€‚æŒæ¡è¿™é¡¹æŠ€æœ¯ï¼Œè®©ä½ çš„åº”ç”¨æ›´åŠ æµç•…ã€å“åº”æ›´åŠ è¿…é€Ÿï¼Œä¸ºç”¨æˆ·å¸¦æ¥æ›´å¥½çš„äº¤äº’ä½“éªŒã€‚

---
### é¡¹ç›®åœ°å€

- [https://github.com/jianzhang96/llm/tree/main/qwen-chatbot](https://github.com/jianzhang96/llm/tree/main/qwen-chatbot)
- [https://gitee.com/codehub/llm/tree/main/qwen-chatbot](https://gitee.com/codehub/llm/tree/main/qwen-chatbot)
