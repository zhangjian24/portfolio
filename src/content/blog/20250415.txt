---
title: 'java-基础'
pubDate: 2025-04-15
description: 'java-基础'
heroImage: '/image/logo.svg'
tags: ["Java"]
---

# 常识
## java 语言特点
1. java是一门易于学习的面相对象的语言
2. 支持多线程和网络编程
3. 编译与解释并存
3. 语言比较成熟，生态系统完善

## JVM、JDK、JRE区别
![](/image/photo_2025-04-15_15-54-22.jpg)

## 字节码的优势
将源代码编译后解释执行，既高效，又具有移植性；

## JIT与AOT的区别
- JIT通过对热点代码编译后的机器码缓存下来，下次执行避免重新解释，提升效率；
- AOT将执行前的代码直接编译成机器码，可以减小资源占用和启动时间，但是无法支持动态特性，如反射、动态代理、动态加载。

## Oracle JDK vs OpenJDK的区别
1. 是否开源：Oracle JDK 是闭源，OpenJDK是开源的；
2. 是否免费：Oracle JDK 限期免费，OpenJDK永久免费；
3. 功能性：Oracle JDK 比 OpenJDK多一些特有功能。

## Java 与 C++ 区别
1. Java 不能直接访问内存，有自动内存管理，内存安全；
2. Java 类只能单继承
3. C++ 支持操作符重载

# 语法

## 注释有哪些？
单行、多行、文档注释

## 标识符与关键字有什么区别
- 标识符就是个名字
- 关键字就是有特殊含义的标识符

## Continue、Break、Return 的区别
- Continue 跳出当前循环，继续下一次循环；
- Break 跳出所有循环，执行循环体下一句；
- Return 结束方法执行，并返回变量；

# 数据类型

## 基本数据类型有哪些
8种基本数据类型：
- 6种数字类型，包括4种整型：byte、short、int、long，2种浮点；float、double；
- 1种字符型：char；
- 1种布尔型：boolean

## 基本类型和包装类型的区别
1. 用途：常量和局部变量用基本类型；参数和成员变量用包装类型。
2. 存储方式：基本类型的局部变量存储在虚拟机栈的局部变量表种；基本类型的常量存储在方法区；包装类型除优化后的栈上分配，基本都在堆上。
3. 占用空间：基本类型占用空间小。
4. 默认值：包装类型的默认值为NULL。
5. 比较方式："==" 对于基本类型是比较内容，对于包装类型是比较地址。


## 对象引用和对象实例
- 对象实例在堆区
- 对象引用在栈区
- 一个引用对应一个实例，一个实例可以对应多个引用

## 自动装箱与拆箱是什么
- 装箱：自动调用valueOf方法将基本类型转换成包装类型
- 拆箱：自动调用value方法将包装类型转换成基本类型

## 包装类型的缓存机制是什么
包装类型通过缓存机制提升性能，自动装箱时，在某个范围内的值每次都返回缓存中的同一个对象，超过的则创建新对象；
Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 TRUE or FALSE。
```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

## 浮点数运算为什么会有精读损失，怎么解决？
十进制小数在转换成二进制过程为，不断乘以 2，直到不存在小数为止，会发生无限循环。可以使用BigDecimal避免精读损失。

## 超过long的整数怎么表示
可以用BigInteger表示，其内部通过`int[]` 处理，性能稍差。

# 方法

## 重载与重写的区别
- 重载：同一个类中，方法名相同，参数不同；
- 重写：发生在父子类之间，父子类的方法名和参数相同，子类的返回值和异常范围小于父类，子类的访问权限大于父类；

## 构造方法有哪些特点？是否可被 重写(override)? 可以没有构造方法吗？
特点：
- 方法名和类名一致
- 没有返回值
- 自动执行

构造方法不能被重写，但是可以重载

如果没有写构造方法，会提供默认无参构造方法

# 面相对象

## 面相对象的三大特性
- 封装：不允许直接访问内部；
- 继承：子类可以继承父类代码；
- 多态：父类引用可以指向子类实例，父类引用调用的方法实现，由指向的子类实例决定。

## 接口与抽象类的区别
- 设计目的：接口主要是为了限制类的行为；抽象类强调从属，共用父类代码。
- 继承与实现：类单继承，接口多继承；类可以实现多个接口。
- 成员变量：接口只能有常量。
- 方法：JDK7以前，接口只能有抽象方法；JDK8以后可以有default和static方法。

## 深拷贝和浅拷贝的区别
- 引用拷贝：拷贝一份引用，但指向不变；
- 浅拷贝：对象会被拷贝，但对象内引用的对象不会拷贝；
- 深拷贝：对象及其引用的对象都会被拷贝；

![](public/image/photo_2025-04-15_19-11-52.jpg)

## `==` 和 equals() 的区别
`==` 对于基本类型是比较内容，对于引用类型是比较内存地址；
equals() 只能用于判断对象是否相等，可以重写，没重写的情况下，继承的是Object，比较的是对象地址；

## 为什么重写equals()必须重写hashCode()
因为对象相等时，哈希值必须相等，但哈希值一样时，对象未必相等。

# String

## String、StringBuffer、StringBuilder 的区别?
- 可变性：String 不可变，String是final类，自身也不提供内部字符数组的修改方法。StringBuffer、StringBuilder都是可变的，继承自AbstractStringBuilder，提供了修改方法。
- 线程安全性：String 是不可变的，所以线程安全；StringBuffer的方法添加了同步锁，所以线程安全，StringBuilder是非线程安全的
- 性能：StringBuilder、StringBuffer、String性能依次降低

## 字符串拼接使用`+`还是`StringBuilder` 的 `append` 的方法
字符串对象通过`+`的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象。
在循环内使用`+`会频繁创建StringBuilder，所以在循环外创建StringBuilder，再调用append方法拼接
```java title="源码" showLineNumbers
package com.zhangjian;

import org.junit.Test;

public class SimpleTesta {

    /**
     * This test method is a placeholder for future unit tests.
     *
     * @throws Exception if any unexpected error occurs during execution
     */
    @Test
    public void test() throws Exception {
        String s = "a";
        for (int i = 0; i < 9; i++) {
            s += 'a' + i;
        }
        System.out.println(s);
    }
}
```

```java title="字节码" showLineNumbers {37,41,45,46,47,51}
// class version 52.0 (52)
// access flags 0x21
public class com/zhangjian/SimpleTesta {

  // compiled from: SimpleTesta.java

  // access flags 0x1
  public <init>()V
   L0
    LINENUMBER 5 L0
    ALOAD 0
    INVOKESPECIAL java/lang/Object.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this Lcom/zhangjian/SimpleTesta; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x1
  public test()V throws java/lang/Exception 
  @Lorg/junit/Test;()
   L0
    LINENUMBER 14 L0
    LDC "a"//加载常量"a"
    ASTORE 1//将栈顶常量存入局部变量1，即s
   L1
    LINENUMBER 15 L1
    ICONST_0//常量0入栈
    ISTORE 2//将栈顶0存入局部变量2，即i
   L2
   FRAME APPEND [java/lang/String I]//创建临时变量，存放'a' + i的结果
    ILOAD 2//入栈循环变量i
    BIPUSH 9//入栈常量9
    IF_ICMPGE L3//大于等于9就跳转到L3
   L4
    LINENUMBER 16 L4
    NEW java/lang/StringBuilder//创建StringBuilder对象实例
    DUP
    INVOKESPECIAL java/lang/StringBuilder.<init> ()V
    ALOAD 1
    INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;//append(s)
    BIPUSH 97
    ILOAD 2
    IADD
    INVOKEVIRTUAL java/lang/StringBuilder.append (I)Ljava/lang/StringBuilder;//append('a'+i)
    INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;//转换成String对象
    ASTORE 1//赋值给局部变量1，即s
   L5
    LINENUMBER 15 L5
    IINC 2 1
    GOTO L2//进行下一轮循环
   L3
    LINENUMBER 18 L3
   FRAME CHOP 1
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    ALOAD 1
    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V
   L6
    LINENUMBER 19 L6
    RETURN
   L7
    LOCALVARIABLE i I L2 L3 2//局部变量i
    LOCALVARIABLE this Lcom/zhangjian/SimpleTesta; L0 L7 0
    LOCALVARIABLE s Ljava/lang/String; L1 L7 1//局部变量s
    MAXSTACK = 3
    MAXLOCALS = 3
}
```

## String#intern 方法有什么作用?
返回与字符串对象内容一致的常量池引用，如果常量池中不存在就先创建。
```java
// s1 指向字符串常量池中的 "Java" 对象
String s1 = "Java";
// s2 也指向字符串常量池中的 "Java" 对象，和 s1 是同一个对象
String s2 = s1.intern();
// 在堆中创建一个新的 "Java" 对象，s3 指向它
String s3 = new String("Java");
// s4 指向字符串常量池中的 "Java" 对象，和 s1 是同一个对象
String s4 = s3.intern();
// s1 和 s2 指向的是同一个常量池中的对象
System.out.println(s1 == s2); // true
// s3 指向堆中的对象，s4 指向常量池中的对象，所以不同
System.out.println(s3 == s4); // false
// s1 和 s4 都指向常量池中的同一个对象
System.out.println(s1 == s4); // true
```
# 异常

## Exception 和 Error 的区别
- Exception 是程序错误，必须处理的是受检异常，非必须的是非受检异常。
- Error 是程序无法处理的错误，虚拟机一般会终止程序。

## Checked Exception 和 Unchecked Exception 有什么区别？
Checked Exception：是必须处理（catch或throws）的异常，否则编译不通过。
Unchecked Exception：RuntimeException 的子类都是非受检异常，可以不处理，编译也可以通过。
## try-catch-finally 如何使用？
try块：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。catch块：用于处理 try 捕获到的异常。finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。
## finally 中的代码一定会执行吗？
程序所在的线程死亡，就不会执行
## try 或 catch 与finally中均有 return 语句时会怎样？
```java title="源码" showLineNumbers
package com.zhangjian;

import org.junit.Test;

public class SimpleTesta {

    /**
     * This test method is a placeholder for future unit tests.
     *
     * @throws Exception if any unexpected error occurs during execution
     */
    @Test
    public void test() throws Exception {
        System.out.println(str());//输出：c
    }

    public static String str(){
        try {
            return "a";//会被忽略
        }catch (Exception e){
            e.printStackTrace();
            return "b";
        }finally {
            return "c";
        }
    }
}
```

```java title="字节码" showLineNumbers {47,63,68}
// class version 52.0 (52)
// access flags 0x21
public class com/zhangjian/SimpleTesta {

  // compiled from: SimpleTesta.java

  // access flags 0x1
  public <init>()V
   L0
    LINENUMBER 5 L0
    ALOAD 0
    INVOKESPECIAL java/lang/Object.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this Lcom/zhangjian/SimpleTesta; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x1
  public test()V throws java/lang/Exception 
  @Lorg/junit/Test;()
   L0
    LINENUMBER 14 L0
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    INVOKESTATIC com/zhangjian/SimpleTesta.str ()Ljava/lang/String;
    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V
   L1
    LINENUMBER 15 L1
    RETURN
   L2
    LOCALVARIABLE this Lcom/zhangjian/SimpleTesta; L0 L2 0
    MAXSTACK = 2
    MAXLOCALS = 1

  // access flags 0x9
  public static str()Ljava/lang/String;
    TRYCATCHBLOCK L0 L1 L2 java/lang/Exception
    TRYCATCHBLOCK L0 L1 L3 null
    TRYCATCHBLOCK L2 L4 L3 null
   L0
    LINENUMBER 19 L0
    LDC "a"
    ASTORE 0
   L1
    LINENUMBER 24 L1
    LDC "c"
    ARETURN//只有finally中的return 有效
   L2
    LINENUMBER 20 L2
   FRAME SAME1 java/lang/Exception
    ASTORE 0
   L5
    LINENUMBER 21 L5
    ALOAD 0
    INVOKEVIRTUAL java/lang/Exception.printStackTrace ()V
   L6
    LINENUMBER 22 L6
    LDC "b"
    ASTORE 1
   L4
    LINENUMBER 24 L4
    LDC "c"
    ARETURN//只有finally中的return 有效
   L3
   FRAME SAME1 java/lang/Throwable
    ASTORE 2
    LDC "c"
    ARETURN//只有finally中的return 有效
    LOCALVARIABLE e Ljava/lang/Exception; L5 L3 0
    MAXSTACK = 1
    MAXLOCALS = 3
}
```

# 泛型
## 泛型有什么作用
编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。
## 泛型有哪几种使用方式
泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。
- 泛型类
```java
//在实例化泛型类时，必须指定T的具体类型
public class Generic<T>{

    private T key;

    public Generic(T key) {
        this.key = key;
    }

    public T getKey(){
        return key;
    }
}
```
- 泛型接口和泛型类一样，在名称后面加上泛型参数`<T>`。
- 泛型方法
```java
   public static < E > void printArray( E[] inputArray )
   {
         for ( E element : inputArray ){
            System.out.printf( "%s ", element );
         }
         System.out.println();
    }
```


# 反射

## 什么是反射
运行时，获取类的信息。

## 反射优缺点
反射为实现框架提供了灵活性和便利；

但反射会降低安全性和性能。

# 序列

# 注解

# IO